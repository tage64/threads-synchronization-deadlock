/* On Mac OS (aka OS X) the ucontext.h functions are deprecated and requires the
   following define.
*/
#define _XOPEN_SOURCE 700

/* On Mac OS when compiling with gcc (clang) the -Wno-deprecated-declarations
   flag must also be used to suppress compiler warnings.
*/

#include <signal.h>   /* SIGSTKSZ (default stack size), MINDIGSTKSZ (minimal
                         stack size) */
#include <stdio.h>    /* puts(), printf(), fprintf(), perror(), setvbuf(), _IOLBF,
                         stdout, stderr */
#include <stdlib.h>   /* exit(), EXIT_SUCCESS, EXIT_FAILURE, malloc(), free() */
#include <string.h>   // memset()
#include <ucontext.h> /* ucontext_t, getcontext(), makecontext(),
                         setcontext(), swapcontext() */
#include <stdbool.h>  /* true, false */
#include <sys/time.h> // ITIMER_REAL, ITIMER_VIRTUAL, ITIMER_PROF, struct itimerval, setitimer()

#include "sthreads.h"

/* Stack size for each context. */
#define STACK_SIZE SIGSTKSZ*100

// Maximum number of threads
#define MAX_NO_THREADS 64
#define TIMEOUT    10          // ms 
#define TIMER_TYPE ITIMER_REAL // Type of timer.


/*******************************************************************************
                             Global data structures

                Add data structures to manage the threads here.
********************************************************************************/

// Array of threads
thread_t threads[MAX_NO_THREADS];

// Index of the next availlable thread id.
// -1 if all thread slots are occupied.
tid_t next_availlable_tid = 0;

// Head of the ready queue. -1 indicates there're no ready threads.
tid_t ready_queue_first = -1;

// Last thread in ready queue. -1 indicates there're no ready threads.
tid_t ready_queue_last = -1;

tid_t running_thread;

// Whether the sthreads machinary is initialized
bool sthreads_initialized = false;




/*******************************************************************************
                             Auxiliary functions

                      Add internal helper functions here.
********************************************************************************/

/* The three types of timers causes different signals.

   type: type of timer, one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF.

   return value: the signal generated by the timer.

 */
int timer_signal(int timer_type) {
  int sig;

  switch (timer_type) {
    case ITIMER_REAL:
      sig = SIGALRM;
      break;
    case ITIMER_VIRTUAL:
      sig = SIGVTALRM;
      break;
    case ITIMER_PROF:
      sig = SIGPROF;
      break;
    default:
      fprintf(stderr, "ERROR: unknown timer type %d!\n", timer_type);
      exit(EXIT_FAILURE);
  }

  return sig;
}


/* Set a timer and a handler for the timer.

   Arguments

   type: type of timer, one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF.

   handler: timer signal handler.

   ms: time in ms for the timer. 

 */
void set_timer(void (*handler)(), int ms) {
  struct itimerval timer;
  struct sigaction sa;

  /* Install signal handler for the timer. */
  memset (&sa, 0, sizeof (sa));
  sa.sa_handler =  handler;
  sigaction (timer_signal(TIMER_TYPE), &sa, NULL);

  /* Configure the timer to expire after ms msec... */
  timer.it_value.tv_sec = 0;
  timer.it_value.tv_usec = ms*1000;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = 0;

  if (setitimer (TIMER_TYPE, &timer, NULL) < 0) {
    perror("Setting timer");
    exit(EXIT_FAILURE);
  };
}

// Disable the timer
// This is used to enter a critical section when threads should not be preempted.
//
// old_timer is a pointer where the old (disabled) timer will be put.
void disable_timer(struct itimerval *old_timer) {
  struct itimerval null_timer;
  null_timer.it_value.tv_sec = 0;
  null_timer.it_value.tv_usec = 0;
  null_timer.it_interval.tv_sec = 0;
  null_timer.it_interval.tv_usec = 0;

  if (setitimer (TIMER_TYPE, &null_timer, old_timer) < 0) {
    perror("Setting timer in disable");
    exit(EXIT_FAILURE);
  };
}

// Resume a timer
void resume_timer(struct itimerval *timer) {
  if (setitimer (TIMER_TYPE, timer, NULL) < 0) {
    perror("Setting timer in resume");
    exit(EXIT_FAILURE);
  };
}

/* Initialize a context.

   ctxt - context to initialize.

   next - successor context to activate when ctx returns. If NULL, the thread
          exits when ctx returns.
 */
void init_context(ucontext_t *ctx, ucontext_t *next) {
  /* Allocate memory to be used as the stack for the context. */
  void *stack = malloc(STACK_SIZE);

  if (stack == NULL) {
    perror("Allocating stack");
    exit(EXIT_FAILURE);
  }

  if (getcontext(ctx) < 0) {
    perror("getcontext");
    exit(EXIT_FAILURE);
  }

  /* Before invoking makecontext(ctx), the caller must allocate a new stack for
     this context and assign its address to ctx->uc_stack, and define a successor
     context and assigns address to ctx->uc_link.
  */

  ctx->uc_link           = next;
  ctx->uc_stack.ss_sp    = stack;
  ctx->uc_stack.ss_size  = STACK_SIZE;
  ctx->uc_stack.ss_flags = 0;
}

/* Initialize context ctx  with a call to function func with zero argument.
 */
void init_context0(ucontext_t *ctx, void (*func)(), ucontext_t *next) {
  init_context(ctx, next);
  makecontext(ctx, func, 0);
}

// Append a thread to the ready queue and set its state to ready.
void ready_queue_append(tid_t tid) {
  if (ready_queue_last < 0)
    ready_queue_first = tid;
  else
    threads[ready_queue_last].next = tid;
  ready_queue_last = tid;
  threads[tid].state = ready;
  threads[tid].next = -1;
}

// Wrapper around yield() that is used as signal handler.
void yield_wrapper(int _sig) {
  yield();
}

// Make a thread running and change its state to running.
// // The state of the previously running state is unmodified.
void make_running(tid_t tid) {
  if (running_thread == tid)
    return;
  
  thread_t *new_running = &threads[tid];
  thread_t *current_running = &threads[running_thread];
  new_running->state = running;
  running_thread = tid;

  set_timer(yield_wrapper, TIMEOUT);
  // We hope the timer doesn't timeout here.
  if (swapcontext(&current_running->ctx, &new_running->ctx) < 0) {
    perror("setcontext");
    exit(EXIT_FAILURE);
  }
}

void select_next_ready() {
  tid_t tid = ready_queue_first;
  if (tid < 0)
    return;
  ready_queue_first = threads[tid].next;
  make_running(tid);
}

/*******************************************************************************
                    Implementation of the Simple Threads API
********************************************************************************/


int  init(){
  // We will create a main thread from the current context.
  ucontext_t main_context;
  if (getcontext(&main_context) < 0) {
    perror("getcontext");
    exit(EXIT_FAILURE);
  }
  if (sthreads_initialized) {
    // We've returned from getcontext the second time after calling setcontext()
    return 1;
  }

  // Create the main thread
  threads[0] = (thread_t){
    .tid = 0,
    .state = running,
    .ctx = main_context,
    .first_join_thread = -1,
  };
  running_thread = 0;
  next_availlable_tid++;
  sthreads_initialized = true;
  setcontext(&main_context);
  
  // Execution of the main thread failed.
  return -1;
}


tid_t spawn(void (*start)()){
  // Critical section
  disable_timer(NULL);

  if (next_availlable_tid < 0)
    return -1;
  tid_t tid = next_availlable_tid;
  next_availlable_tid++;
  ucontext_t ctx;
  init_context0(&ctx, start, NULL);
  threads[tid] = (thread_t){
    .tid = tid,
    .ctx = ctx,
    .first_join_thread = -1,
    .state = running
  };

  ready_queue_append(running_thread);
  make_running(tid);
  return tid;
}

void yield(){
  // Critical section
  disable_timer(NULL);

  ready_queue_append(running_thread);
  select_next_ready();
}

void  done(){
  // Critical section
  disable_timer(NULL);
  thread_t *thread = &threads[running_thread];
  thread->state = terminated;
  // Loop threw all waiting thread and change their state from waiting to ready.
  tid_t join_thread = thread->first_join_thread;
  while (join_thread >= 0) {
    ready_queue_append(join_thread);
    join_thread = threads[join_thread].next;
  }
  select_next_ready();
}

tid_t join(tid_t tid) {
  // Critical section
  struct itimerval paused_timer;
  disable_timer(&paused_timer);

  thread_t *wait_for = &threads[tid];
  thread_t *current_thread = &threads[running_thread];

  // Prepend current_thread to the linked list of waiting threads.
  current_thread->next = wait_for->first_join_thread;
  wait_for->first_join_thread = running_thread;
  current_thread->state = waiting;
  select_next_ready();

  resume_timer(&paused_timer);
  return tid;
}
